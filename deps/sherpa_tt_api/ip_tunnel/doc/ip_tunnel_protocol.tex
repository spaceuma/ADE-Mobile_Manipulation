\documentclass{scrartcl}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{soul}
\usepackage{amsmath}
\usepackage[ngerman]{babel}
\usepackage{tabularx}

\usepackage{geometry}
\geometry{
  includeheadfoot,
  left=20mm,
  right=20mm,
  top=20mm,
  bottom=20mm
}

\usepackage{lastpage}
\usepackage{bytefield}
\usepackage{tikz}

\usepackage[headsepline,footsepline]{scrpage2}
\pagestyle{scrheadings}
\ihead{IP-Tunnel Protocol}
\chead{}
\ohead{\GetDatum}
\cfoot{}
\ofoot{\thepage{} / \pageref{LastPage}}

\setlength{\parindent}{0pt}

\newcommand{\SetDatum}[1]{\newcommand{\GetDatum}{#1}}

\SetDatum{\today}

\begin{document}

\section*{Protocol}

\subsection*{Control-Header}
The control header is prepended to each frame. It can be used to store informations like the name of the frame or its length. In addition it can be used to acknowledge that a frame has been received successfully or it can be used to request missing fragments. Table \ref{tab:control_header} describes the structure of the control header and table \ref{tab:control_informations} lists the available control IDs.

\begin{table}[ht]
\begin{bytefield}[bitwidth=3em]{11}
\bitbox[e]{1}{\tiny 6} & \bitbox[e]{1}{\tiny 7} & \bitbox[e]{1}{\tiny 8} & \bitbox[e]{1}{\tiny 9} & \bitbox[e]{1}{\tiny 10} & \bitbox[e]{1}{\tiny 11} & \bitbox[e]{1}{\tiny 12} & \bitbox[e]{1}{\tiny 13} & \bitbox[e]{1}{\tiny $\ldots$} & \bitbox[e]{1}{\tiny $n$} & \bitbox[e]{1}{\tiny $n+1$} \\
\bitbox{1}{$ack\_r$} & \bitbox{2}{$control\_len$} & \bitbox{2}{$control\_id$} & \bitbox{2}{$data\_len$} & \bitbox{3}{$control\_data$} & \bitbox{1}{$\ldots$}\\
\bitbox[t]{3}{} & \bitbox[t]{7}{$\underbrace{\hspace{21em}}_{\text{\normalsize $control\_len$ bytes}}$}
\end{bytefield}

\hfill \\
\centering
\begin{tabularx}{\textwidth}{lX} 
$ack\_r$ & Defines whether a frame has to be acknowledged: 
$0\rightarrow$ No ACK required. 
$1\rightarrow$ The sender expects an ACK (see table \ref{tab:control_informations} \textit{ACKED\_FRAME}). 
$2\rightarrow$ The sender expects a list of missing fragments (see table \ref{tab:control_informations} \textit{MISSING\_FRAGMENTS}). \\
$control\_len$  & Number of bytes of all control informations. \\
$control\_id$   & Control information ID (see table \ref{tab:control_informations}). \\
$data\_len$     & Length of the following control data. \\
$control\_data$ & Control data encoded as a character string. \\
\end{tabularx}
\caption{Control-Header Elements}
\label{tab:control_header}
\end{table}


\begin{table}[ht]
\centering
\begin{tabularx}{\textwidth}{lcX} 
\textbf{Name}                 & \textbf{ID}  & \textbf{Description}\\
\small{\textit{PORT\_NAME}}          & 1 & Contains the name of the frame. Within a Rock environment the name of the according port is used to identify the frame. \\
\small{\textit{ACKED\_FRAME}}        & 2 & Allows to acknowledge the receiving of a frame. In this case the control\_data contains the ID of the received frame.\\
\small{\textit{PAKET\_LEN}}          & 3 & Stores the length of the frame data (encoded as a character string) following the control header. \\
\small{\textit{MISSING\_FRAGMENTS}}  & 4 & In this case the control data contains the ID of the received frame followed by the IDs of the missing fragments. If no fragments are missing the frame has been received successfully.
\end{tabularx}
\caption{Control Informations}
\label{tab:control_informations}
\end{table}


\newpage
\subsection*{Fragment-Header}
SequencedComm splits the data (frame) into single fragments acoording to the configuration parameter \textit{max\_fragment\_size} which is required if the size of the data exceeds the maximum size of an UDP/TCP datagram package (65507 byte). The fragment header is prepended to each single fragment.\footnote{There is always one control header, the frame data is optional and the number of fragment headers depends on the overall frame size.} 

\begin{table}[ht]
\begin{bytefield}[bitwidth=3em]{6}
\bitheader{0-6} \\
\bitbox{2}{$frame\_id$} & \bitbox{2}{$frag\_nr$} & \bitbox{2}{$frag\_next$} & \bitbox{1}{$\ldots$}
\end{bytefield}

\hfill \\

\centering
\begin{tabularx}{\textwidth}{lX} 
$frame\_id$ & Identifies a complete frame. All fragments of a frame are assigned the same frame ID (starting with 1). \\
$frag\_nr$ & Identifies a single fragment (starting with 0). For each additional fragment the fragment number is increased by one. \\
$frag\_next$ & Identifies the next fragment ($frag\_nr$ + 1). If this value is 0 the last fragment of the frame has been found.\\
\end{tabularx}
\caption{Fragment-Header}
\label{tab:fragment_header}
\end{table}

\newpage
\section*{Examples}

\subsection*{Sending an ACK frame}\hfill \\
In the following example frame (ID 42) is sent which is not fragmented and which should be acknowledged by the receiver. Therefore the ACK byte $ack\_r$ is set to 1 / true. The length of both control informations is 20 Byte:\\ 2 (control ID) + 2 (control length) + 10 (control content) + 2 + 2 + 2 = 12 + 2 * 4 = 20 Byte. \\

\begin{bytefield}[bitwidth=1em]{31}
\bitheader{0-31} \\
\bitbox{2}{$42$} & \bitbox{2}{$0$} & \bitbox{2}{$0$} & \bitbox{1}{$1$} & \bitbox{2}{\tiny $12+2*4$} &  \bitbox{2}{$1$} & \bitbox{2}{$10$} & \bitbox{10}{$"motion\_cmd"$} 
\bitbox{2}{$3$} & \bitbox{2}{$2$} & \bitbox{2}{$"24"$} \bitbox{3}{} \\
\bitbox{21}{$/base/commands/Motion2D$}
\end{bytefield}

\hfill \\
The receiver replies with an ACK frame which just contains the control header and no additional data. The ID of the frame is 55, it is not fragmented, the control length is 6 Byte and it acknowledges the receiving of frame 42.\\

\begin{bytefield}[bitwidth=1em]{15}
\bitheader{0-14} \\
\bitbox{2}{$55$} & \bitbox{2}{$0$} & \bitbox{2}{$0$} & \bitbox{1}{$0$} & \bitbox{2}{\tiny $2~+$ $1*4$} &  \bitbox{2}{$2$} & \bitbox{2}{$2$} & \bitbox{2}{$"42"$}
\end{bytefield}


\subsection*{Sending of a fragmented frame}
In this example a poincloud is sent which size exceeds the maximum frame size defined by the configuration parameter \textit{max\_fragment\_size}. Therefore the frame is split into two fragments. The frame ID for both fragments is 96, the fragment-ID and the next-fragment-ID for the first fragment are 0 and 1 and for the second fragment 1 and 0 (0 identifies the last fragment of the frame). The fragment header is prepended to both fragments.\\

\begin{bytefield}[bitwidth=1em]{31}
\bitheader{0-31} \\
\bitbox{2}{$96$} & \bitbox{2}{$0$} & \bitbox{2}{$1$} & \bitbox{1}{$0$} & \bitbox{2}{\tiny $17+2*4$} &  \bitbox{2}{$1$} & \bitbox{2}{$13$} & \bitbox{13}{$"pointcloud\_in"$} 
\bitbox{2}{$3$} & \bitbox{2}{$4$} & \bitbox{2}{\tiny $"2050"$} \\
& \bitbox{2}{} & \bitbox{30}{$pointcloud$ \textit{data part 1 ...}} \\
\hfill \\
\bitheader{0-31} \\
\bitbox{2}{$96$} & \bitbox{2}{$1$} & \bitbox{2}{$0$} \bitbox{26}{$/pointcloud$ \textit{data part 2 ...}} \\
\end{bytefield}


\subsection*{Request missing fragments}
In this example $ack\_r$ is set to 2 which tells the receiver that it can request missing fragments. The data is split into three fragments which are stored by the sender.\\

\begin{bytefield}[bitwidth=1em]{31}
\bitheader{0-31} \\
\bitbox{2}{$42$} & \bitbox{2}{$0$} & \bitbox{2}{$0$} & \bitbox{1}{$2$} & \bitbox{2}{\tiny $15+2*4$} &  \bitbox{2}{$1$} & \bitbox{2}{$11$} & \bitbox{15}{$"pointclouds"$} 
\bitbox{2}{$3$} & \bitbox{2}{$4$} \\
 \bitbox{4}{$"4000"$} & \bitbox{28}{$<data>...$}
\end{bytefield}

\hfill \\
We assume that the middle fragment has been lost during sending so the receiver requests for frame 42 fragment 1.
\\

\begin{bytefield}[bitwidth=1em]{17}
\bitheader{0-16} \\
\bitbox{2}{$55$} & \bitbox{2}{$0$} & \bitbox{2}{$0$} & \bitbox{1}{$0$} & \bitbox{2}{\tiny $4~+$ $1*4$} &  \bitbox{2}{$4$} & \bitbox{2}{$4$} & \bitbox{4}{$"42~1"$}
\end{bytefield}

\hfill \\
After the missing fragment has been resent and received successfully the receiver tells the sender that all fragments have been received by sending another \textit{MISSING\_FRAGMENTS} frame just containing the ID of the received frame. \\

\begin{bytefield}[bitwidth=1em]{15}
\bitheader{0-14} \\
\bitbox{2}{$58$} & \bitbox{2}{$0$} & \bitbox{2}{$0$} & \bitbox{1}{$0$} & \bitbox{2}{\tiny $2~+$ $1*4$} &  \bitbox{2}{$4$} & \bitbox{2}{$2$} & \bitbox{4}{$"42"$}
\end{bytefield}

\end{document}
